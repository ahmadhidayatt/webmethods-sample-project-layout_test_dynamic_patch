/*
* Copyright © 2010 - 2013 Apama Ltd.
* Copyright © 2013 - 2018 Software AG, Darmstadt, Germany and/or its licensors
*
* SPDX-License-Identifier: Apache-2.0
*
*   Licensed under the Apache License, Version 2.0 (the "License");
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an "AS IS" BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*   limitations under the License.                                                            
*
*/

pipeline {
    agent any 
    
    parameters {
        string(name: 'IS_PACKAGES_PATH',
               defaultValue: './assets/IS/Packages',
               description: 'Path to IS Packages directory relative to workspace')
        choice(name: 'DEPLOYMENT_MODE',
               choices: ['full', 'patch'],
               description: 'Select deployment mode')
    }

    stages {
        stage('Build') {
            steps {
                bat "${env.SAG_HOME}/common/lib/ant/bin/ant -DSAGHome=${env.SAG_HOME} -DSAG_CI_HOME_DYNAMIC=${env.SAG_CI_HOME_DYNAMIC} -DprojectName=${env.JOB_NAME} -DisPackages=${params.IS_PACKAGES_PATH} build"
            }
        }
        
        stage('Deploy') {
            steps {
                script {
                    if (params.DEPLOYMENT_MODE == 'patch') {
                        def objectsList = generateObjectsList(params.IS_PACKAGES_PATH)
                        if (!objectsList) {
                            error('No packages found for patch deployment')
                        }
                        
                        bat "${env.SAG_HOME}/common/lib/ant/bin/ant -DSAGHome=${env.SAG_HOME} -DSAG_CI_HOME_DYNAMIC=${env.SAG_CI_HOME_DYNAMIC} -DprojectName=${env.JOB_NAME} -DobjectsToDeploy=\"${objectsList}\" patch"
                    } else {
                        bat "${env.SAG_HOME}/common/lib/ant/bin/ant -DSAGHome=${env.SAG_HOME} -DSAG_CI_HOME_DYNAMIC=${env.SAG_CI_HOME_DYNAMIC} -DprojectName=${env.JOB_NAME} deploy"
                    }
                }
            }
        }
        
        stage('Test') {
            steps {
                bat "${env.SAG_HOME}/common/lib/ant/bin/ant -DSAGHome=${env.SAG_HOME} -DSAG_CI_HOME_DYNAMIC=${env.SAG_CI_HOME_DYNAMIC} -DprojectName=${env.JOB_NAME} test"
                junit 'report/**/*.xml'
            }
        }
    }
    
    post {
        success {
            script {
                if (params.DEPLOYMENT_MODE == 'patch') {
                    def objectsList = generateObjectsList(params.IS_PACKAGES_PATH)
                    echo "Patch deployment successful for services: ${objectsList}"
                } else {
                    echo "Full deployment completed successfully"
                }
            }
        }
    }
}

// Fungsi untuk generate list objects dari package directory dengan struktur bertingkat
def generateObjectsList(packagesPath) {
    def dirPath = "${env.WORKSPACE}/${packagesPath}"
    def dir = new File(dirPath)
    if (!dir.exists()) {
        error("Package directory not found: ${dir.path}")
    }
    
    def objects = []
    def excludedDirs = ['config', 'resources', 'replicate']
    
    // Gunakan findFiles untuk mendapatkan semua folder
    def allDirs = findFiles glob: '**/', includes: dirPath + '/**'
    
    allDirs.each { file ->
        if (file.directory) {
            def absolutePath = file.path
            // Dapatkan path relatif terhadap packagesPath
            def relativePath = absolutePath.substring(dirPath.length() + 1)
            def normalizedPath = relativePath.replace('\\', '/')
            
            // Periksa apakah path ini dikecualikan
            def isExcluded = false
            for (excluded in excludedDirs) {
                if (normalizedPath.contains("/${excluded}/") || normalizedPath.endsWith("/${excluded}")) {
                    isExcluded = true
                    break
                }
            }
            
            if (!isExcluded && normalizedPath) {
                objects.add(normalizedPath)
            }
        }
    }
    
    return objects.join(',')
}
